<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chakkar - Black Hole Spaghettification</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #blackhole-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #blackhole {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #000;
            box-shadow: 0 0 20px 2px rgba(255, 255, 255, 0.1);
            /* Subtle event horizon glow */
            z-index: 52;
        }

        /* Accretion Disk */
        #accretion-disk {
            position: absolute;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: radial-gradient(transparent 30%, rgba(255, 200, 150, 0.2) 40%, rgba(255, 100, 50, 0.6) 50%, rgba(255, 255, 255, 0.8) 55%, rgba(100, 150, 255, 0.4) 70%, transparent 80%);
            box-shadow:
                0 0 30px rgba(255, 150, 50, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            z-index: 51;
            transform: scaleY(0.4);
            animation: spinDisk 10s linear infinite;
            filter: blur(1px);
        }

        /* Photon Ring (The thin bright ring around the shadow) */
        #photon-ring {
            position: absolute;
            width: 86px;
            height: 86px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            z-index: 53;
            opacity: 0.7;
        }

        @keyframes spinDisk {
            0% {
                transform: rotate(0deg) scaleY(0.4);
            }

            100% {
                transform: rotate(360deg) scaleY(0.4);
            }
        }

        .falling-img {
            position: fixed;
            z-index: 40;
            /* Behind blackhole if strictly simpler, but we want scaling/disappearing logic to handle visibility */
            transform-origin: center center;
            overflow: hidden;
            will-change: transform, opacity, filter;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <canvas id="canvas-bg"></canvas>
    <div id="blackhole-container">
        <div id="accretion-disk"></div>
        <div id="blackhole"></div>
        <div id="photon-ring"></div>
    </div>

    <script>
        const imagePaths = [
            'newpic/IMG-20260130-WA0003.jpg.jpeg',
            'newpic/IMG-20260116-WA0003.jpg.jpeg',
            'newpic/IMG-20251205-WA0004.jpg.jpeg',
            'newpic/IMG-20251104-WA0004.jpg.jpeg',
            'newpic/IMG-20251104-WA0003.jpg.jpeg',
            'newpic/1.jpeg'
        ];

        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const eventHorizonRadius = 40; // The actual black hole void (80px diameter / 2)
        const accretionDiskRadius = 90; // Visible disk
        const gravityWell = 500; // Gravity starts pulling here

        // Draw background stars
        const canvas = document.getElementById('canvas-bg');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        function drawStars() {
            ctx.fillStyle = 'white';
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                // Avoid drawing stars inside the black hole area
                const dx = x - centerX;
                const dy = y - centerY;
                if (Math.sqrt(dx * dx + dy * dy) < 100) continue;

                const r = Math.random() * 1.2;
                ctx.globalAlpha = Math.random() * 0.8 + 0.2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }
        drawStars();

        let activeImages = [];
        let imageQueue = [];

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function getRandomImage() {
            if (imagePaths.length === 0) return '';
            if (imagePaths.length === 1) return imagePaths[0];

            // If queue is empty, refill it with a shuffled copy of all images
            if (imageQueue.length === 0) {
                let newBatch = [...imagePaths];
                shuffleArray(newBatch);

                // Prevent the first image of new batch being the same as the last used image
                // (This handles the 'reshuffle' boundary case)
                if (window.lastUsedImage && newBatch[0] === window.lastUsedImage) {
                    // Swap first element with last element
                    [newBatch[0], newBatch[newBatch.length - 1]] = [newBatch[newBatch.length - 1], newBatch[0]];
                }

                imageQueue = newBatch;
            }

            const image = imageQueue.shift(); // Take from the front
            window.lastUsedImage = image;
            return image;
        }

        function spawnImage() {
            const img = document.createElement('img');
            const src = getRandomImage();
            img.src = src;
            img.className = 'falling-img';

            const size = Math.random() * 80 + 80; // 80-160px
            img.style.width = size + 'px';
            img.style.height = 'auto'; // Maintain aspect ratio initially

            // Spawn at random edge of screen or further out
            const spawnRadius = Math.max(window.innerWidth, window.innerHeight) * 0.6;
            const angle = Math.random() * Math.PI * 2;

            const x = centerX + Math.cos(angle) * spawnRadius;
            const y = centerY + Math.sin(angle) * spawnRadius;

            img.style.left = x + 'px';
            img.style.top = y + 'px';

            // Physics state
            img.posX = x;
            img.posY = y;

            // Initial velocity: mostly towards center but with some tangential component (orbit)
            const velocityMag = Math.random() * 2 + 1;
            const angleToCenter = Math.atan2(centerY - y, centerX - x);
            // Add a small spiral offset (tangential velocity) so it swirls
            const spiralOffset = (Math.random() - 0.5) * 0.5;

            img.vx = Math.cos(angleToCenter + spiralOffset) * velocityMag;
            img.vy = Math.sin(angleToCenter + spiralOffset) * velocityMag;

            img.baseSize = size;
            img.spawnTime = Date.now();

            document.body.appendChild(img);
            activeImages.push(img);
        }

        function animate() {
            activeImages = activeImages.filter(img => {
                if (!img.parentElement) return false;

                // Calculate distance to center
                const dx = centerX - img.posX;
                const dy = centerY - img.posY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angleToCenter = Math.atan2(dy, dx);

                // GRAVITY: Inverse square law-ish acceleration
                // Closer = much faster
                let gForce = 500 / (dist * dist + 100);
                gForce = Math.min(gForce, 2); // Cap acceleration

                img.vx += Math.cos(angleToCenter) * gForce;
                img.vy += Math.sin(angleToCenter) * gForce;

                // Friction / Drag (simulating accretion disk drag) if very close
                if (dist < accretionDiskRadius * 2) {
                    img.vx *= 0.98;
                    img.vy *= 0.98;
                }

                // Update position
                img.posX += img.vx;
                img.posY += img.vy;

                // SPAGHETTIFICATION (Restored Tidal Forces)
                // 1. Rotate image to align with radial line to center
                // 2. Stretch along X (radial) axis based on proximity
                // 3. Compress along Y (tangential) axis

                let stretch = 1;
                let compress = 1;
                let opacity = 1;
                let redshift = 0; // sepia/saturate shift

                if (dist < gravityWell) {
                    // Factor 0 to 1 as it gets closer
                    const gravityFactor = Math.max(0, (gravityWell - dist) / gravityWell);

                    // Exponential stretching near event horizon
                    // At dist=80 (near horizon), we want huge stretch
                    stretch = 1 + (Math.pow(gravityFactor, 3) * 15); // stretch up to 16x

                    // Compression (volume preservation would implication x*y=1, so y = 1/x)
                    // But physically, tidal forces compress inwards
                    compress = Math.max(0.02, 1 / (stretch * 0.5));

                    // Redshift effect: darken and shift color
                    opacity = Math.min(1, dist / (eventHorizonRadius * 1.5));
                }

                // Visual transform
                // Important: Transform order. 
                // 1. Translate to position
                // 2. Rotate to face center
                // 3. Scale

                // The angle we want: The image "top" or "right" should point to center.
                // Using scale(x, y): x is horizontal stretch. So we want image X-axis to point to center.
                // Angle is angleToCenter.
                const rotationDeg = angleToCenter * (180 / Math.PI);

                img.style.left = img.posX + 'px';
                img.style.top = img.posY + 'px';

                img.style.transform = `
                    translate(-50%, -50%)
                    rotate(${rotationDeg}deg)
                    scale(${stretch}, ${compress})
                `;

                // "Redshift" and fading near horizon
                // As it falls in, time dilation makes it fade/redshift
                if (dist < accretionDiskRadius * 1.5) {
                    img.style.filter = `sepia(0.5) hue-rotate(-50deg) brightness(${dist / 200}) blur(${stretch * 0.5}px)`;
                } else {
                    img.style.filter = 'none';
                }

                img.style.opacity = opacity;

                // Cleanup
                // If it hits the event horizon (or very close), remove it
                if (dist < eventHorizonRadius) {
                    img.remove();
                    return false;
                }

                // If it flies off screen (unlikely with gravity but possible)
                if (dist > Math.max(window.innerWidth, window.innerHeight) * 1.5 && gForce < 0.01) {
                    img.remove();
                    return false;
                }

                return true;
            });

            requestAnimationFrame(animate);
        }
        animate();

        setInterval(spawnImage, 800);
    </script>
</body>

</html>